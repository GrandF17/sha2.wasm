#ifndef HMAC_HPP
#define HMAC_HPP

#include <cstdint>
#include <cstring>

template<class Hash>
class HMAC {
private:
    Hash inner_hash;

    uint8_t ipad[Hash::block_size];
    uint8_t opad[Hash::block_size];

public:
    static constexpr size_t block_size  = Hash::block_size;
    static constexpr size_t digest_size = Hash::digest_size;

    void init(const uint8_t* key, size_t key_len) {
        uint8_t k0[block_size] = {0};

        if (key_len > block_size) {
            Hash tmp;
            tmp.init();
            tmp.update(key, key_len);

            uint8_t hash_out[digest_size];
            tmp.digest(hash_out);
            tmp.destroy();

            memcpy(k0, hash_out, digest_size);
        } else {
            memcpy(k0, key, key_len);
        }

        for (size_t i = 0; i < block_size; ++i) {
            ipad[i] = k0[i] ^ 0x36;
            opad[i] = k0[i] ^ 0x5c;
        }

        inner_hash.init();
        inner_hash.update(ipad, block_size);
    }

    void update(const uint8_t* msg, size_t len) {
        inner_hash.update(msg, len);
    }

    void compute(uint8_t (&out)[digest_size]) {
        uint8_t inner[digest_size];

        inner_hash.digest(inner);
        inner_hash.destroy();

        Hash outer;
        outer.init();
        outer.update(opad, block_size);
        outer.update(inner, digest_size);
        outer.digest(out);
        outer.destroy();
    }

    void destroy() {
        inner_hash.destroy();

        std::memset(ipad, 0, block_size);
        std::memset(opad, 0, block_size);
    }
};

#endif